<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>글자 따라쓰기 연습</title>
    <!-- Tailwind CSS를 사용하여 깔끔한 디자인을 적용합니다. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 기본 폰트 및 부드러운 스타일링 적용 */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent; /* 터치 시 파란색 하이라이트 제거 */
        }
        /* 캔버스가 부모 요소의 크기에 맞게 조절되도록 설정 */
        #writing-canvas {
            width: 100%;
            height: 100%;
            touch-action: none; /* 모바일에서 스크롤 대신 그리기가 되도록 설정 */
        }
        .control-button {
            transition: all 0.2s ease-in-out;
        }
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .control-button.active {
            background-color: #4f46e5;
            color: white;
            transform: translateY(0);
        }
        /* 피드백 메시지를 위한 애니메이션 */
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: scale(0.9); }
            10%, 90% { opacity: 1; transform: scale(1); }
        }
        #feedback-container {
            animation: fadeInOut 2.5s ease-in-out forwards;
            display: none; /* 평소에는 숨김 */
        }
    </style>
    <!-- Google Fonts 로드 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto bg-white rounded-2xl shadow-xl p-4 sm:p-6 md:p-8">
        
        <header class="text-center mb-6">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-800" style="font-family: 'Noto Sans KR', sans-serif;">글자 따라쓰기</h1>
            <p class="text-gray-500 mt-2">연습하고 싶은 글자를 선택하고 따라 써보세요.</p>
        </header>

        <!-- 글자 선택 버튼 영역 -->
        <div id="controls" class="mb-4">
            <div class="mb-4">
                <h2 class="text-lg font-bold text-gray-700 mb-2" style="font-family: 'Noto Sans KR', sans-serif;">한글</h2>
                <div id="hangul-buttons" class="flex flex-wrap gap-2">
                    <!-- 자바스크립트로 버튼 생성 -->
                </div>
            </div>
            <div>
                <h2 class="text-lg font-bold text-gray-700 mb-2" style="font-family: 'Noto Sans KR', sans-serif;">알파벳</h2>
                <div id="alphabet-buttons" class="flex flex-wrap gap-2">
                    <!-- 자바스크립트로 버튼 생성 -->
                </div>
            </div>
        </div>

        <!-- 글씨 쓰는 캔버스 영역 -->
        <div class="relative w-full aspect-square bg-gray-50 rounded-xl border-2 border-gray-200 overflow-hidden">
            <canvas id="writing-canvas"></canvas>
            <!-- 정확도 피드백 메시지 -->
            <div id="feedback-container" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                <p id="feedback-message" class="text-4xl font-bold" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.2);"></p>
            </div>
        </div>

        <!-- 지우기 버튼 -->
        <div class="mt-6 text-center">
            <button id="clear-button" class="w-full sm:w-auto bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 transition-transform transform hover:scale-105">
                다시 해보기
            </button>
        </div>
    </div>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('writing-canvas');
            const ctx = canvas.getContext('2d');
            const feedbackContainer = document.getElementById('feedback-container');
            const feedbackMessage = document.getElementById('feedback-message');

            const hangulButtonsContainer = document.getElementById('hangul-buttons');
            const alphabetButtonsContainer = document.getElementById('alphabet-buttons');
            const clearButton = document.getElementById('clear-button');

            // 연습할 글자 목록
            const hangulChars = ['ㄱ', 'ㄴ', 'ㄷ', 'ㄹ', 'ㅁ']; // 샘플 글자
            const alphabetChars = 'ABCDE'.split('');

            // 정확도 판별을 위한 글자 데이터 (시작점, 끝점)
            // 좌표는 0~1 사이의 상대값으로 정의
            const characterData = {
                'ㄱ': { start: { x: 0.2, y: 0.3 }, end: { x: 0.8, y: 0.7 } },
                'ㄴ': { start: { x: 0.2, y: 0.3 }, end: { x: 0.2, y: 0.7 } },
                'ㄷ': { start: { x: 0.2, y: 0.3 }, end: { x: 0.8, y: 0.7 } },
                'A': { start: { x: 0.5, y: 0.2 }, end: { x: 0.8, y: 0.8 } },
                'B': { start: { x: 0.3, y: 0.2 }, end: { x: 0.3, y: 0.8 } },
            };

            let isDrawing = false;
            let currentCharacter = 'ㄱ';
            let activeButton = null;
            let userPath = []; // 사용자가 그린 경로 저장

            function resizeCanvas() {
                const parent = canvas.parentElement;
                const size = parent.clientWidth;
                canvas.width = size;
                canvas.height = size;
                drawTemplateCharacter();
            }

            function drawTemplateCharacter() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#e0e0e0';
                ctx.font = `bold ${canvas.width * 0.7}px 'Noto Sans KR', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(currentCharacter, canvas.width / 2, canvas.height / 2 + canvas.height * 0.05);
            }

            // 그리기 시작 함수
            function startDrawing(e) {
                isDrawing = true;
                userPath = [getCoordinates(e)]; // 경로 초기화 및 시작점 추가
                ctx.beginPath();
                const { x, y } = getCoordinates(e);
                ctx.moveTo(x, y);
            }

            // 그리는 중 함수
            function draw(e) {
                if (!isDrawing) return;
                e.preventDefault();

                const { x, y } = getCoordinates(e);
                userPath.push({x, y}); // 경로에 점 추가

                // 실시간으로 그리기
                ctx.lineWidth = Math.max(8, canvas.width * 0.04);
                ctx.lineCap = 'round';
                ctx.strokeStyle = '#3730a3';
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
            }

            // 그리기 종료 및 정확도 판별 함수
            function stopDrawing() {
                if (!isDrawing) return;
                isDrawing = false;
                ctx.beginPath();
                checkAccuracy(); // 그리기가 끝나면 정확도 판별
            }
            
            // 정확도 판별 로직
            function checkAccuracy() {
                const data = characterData[currentCharacter];
                // 정확도 데이터가 없는 글자는 판별하지 않음
                if (!data || userPath.length < 2) {
                    return;
                }

                const canvasSize = canvas.width;
                const threshold = canvasSize * 0.25; // 25% 오차 허용

                const userStart = userPath[0];
                const userEnd = userPath[userPath.length - 1];

                // 데이터에 정의된 상대 좌표를 실제 캔버스 좌표로 변환
                const templateStart = { x: data.start.x * canvasSize, y: data.start.y * canvasSize };
                const templateEnd = { x: data.end.x * canvasSize, y: data.end.y * canvasSize };
                
                // 사용자 입력의 시작/끝점과 정답의 시작/끝점 사이의 거리 계산
                const distStart = Math.hypot(userStart.x - templateStart.x, userStart.y - templateStart.y);
                const distEnd = Math.hypot(userEnd.x - templateEnd.x, userEnd.y - templateEnd.y);

                if (distStart < threshold && distEnd < threshold) {
                    showFeedback(true); // 성공
                } else {
                    showFeedback(false); // 실패
                }
            }

            // 사용자에게 피드백 메시지를 보여주는 함수
            function showFeedback(isSuccess) {
                feedbackContainer.style.display = 'flex';
                if (isSuccess) {
                    feedbackMessage.textContent = '참 잘했어요!';
                    feedbackMessage.style.color = '#22c55e'; // 초록색
                } else {
                    feedbackMessage.textContent = '다시 해볼까요?';
                    feedbackMessage.style.color = '#ef4444'; // 빨간색
                }
                // 애니메이션이 끝나면 메시지 숨김
                setTimeout(() => {
                    feedbackContainer.style.display = 'none';
                    if (!isSuccess) {
                       clearUserDrawing(); // 실패 시 자동으로 지워주기
                    }
                }, 2400);
            }


            function getCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                let x, y;
                if (e.touches && e.touches.length > 0) {
                    x = e.touches[0].clientX - rect.left;
                    y = e.touches[0].clientY - rect.top;
                } else {
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                return { x, y };
            }

            // 사용자가 그린 선만 지우고 배경 글자는 남겨두는 함수
            function clearUserDrawing() {
                drawTemplateCharacter();
            }
            
            function createButtons(container, chars) {
                chars.forEach(char => {
                    const button = document.createElement('button');
                    button.textContent = char;
                    button.className = 'control-button w-10 h-10 sm:w-12 sm:h-12 rounded-lg bg-gray-200 text-gray-700 font-bold text-xl';
                    button.style.fontFamily = "'Noto Sans KR', sans-serif";
                    
                    button.addEventListener('click', () => {
                        currentCharacter = char;
                        clearUserDrawing();
                        
                        if (activeButton) {
                            activeButton.classList.remove('active');
                        }
                        button.classList.add('active');
                        activeButton = button;
                    });

                    container.appendChild(button);

                    if (char === currentCharacter) {
                        button.classList.add('active');
                        activeButton = button;
                    }
                });
            }

            function init() {
                createButtons(hangulButtonsContainer, hangulChars);
                createButtons(alphabetButtonsContainer, alphabetChars);
                
                resizeCanvas();
                drawTemplateCharacter();

                canvas.addEventListener('mousedown', startDrawing);
                canvas.addEventListener('mousemove', draw);
                canvas.addEventListener('mouseup', stopDrawing);
                canvas.addEventListener('mouseout', stopDrawing);

                canvas.addEventListener('touchstart', startDrawing, { passive: false });
                canvas.addEventListener('touchmove', draw, { passive: false });
                canvas.addEventListener('touchend', stopDrawing);

                clearButton.addEventListener('click', clearUserDrawing);

                window.addEventListener('resize', resizeCanvas);
            }

            init();
        });
    </script>
</body>
</html>
